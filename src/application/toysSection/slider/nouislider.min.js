/*! nouislider - 14.6.2 - 9/16/2020 */
!(function (t) { typeof define === 'function' && define.amd ? define([], t) : typeof exports === 'object' ? module.exports = t() : window.noUiSlider = t(); }(() => {
  const lt = '14.6.2'; function ut(t) { t.parentElement.removeChild(t); } function a(t) { return t != null; } function ct(t) { t.preventDefault(); } function o(t) { return typeof t === 'number' && !isNaN(t) && isFinite(t); } function pt(t, e, r) { r > 0 && (ht(t, e), setTimeout(() => { mt(t, e); }, r)); } function ft(t) { return Math.max(Math.min(t, 100), 0); } function dt(t) { return Array.isArray(t) ? t : [t]; } function e(t) { const e = (t = String(t)).split('.'); return e.length > 1 ? e[1].length : 0; } function ht(t, e) { t.classList && !/\s/.test(e) ? t.classList.add(e) : t.className += ` ${e}`; } function mt(t, e) { t.classList && !/\s/.test(e) ? t.classList.remove(e) : t.className = t.className.replace(new RegExp(`(^|\\b)${e.split(' ').join('|')}(\\b|$)`, 'gi'), ' '); } function gt(t) { const e = void 0 !== window.pageXOffset; const r = (t.compatMode || '') === 'CSS1Compat'; return { x: e ? window.pageXOffset : r ? t.documentElement.scrollLeft : t.body.scrollLeft, y: e ? window.pageYOffset : r ? t.documentElement.scrollTop : t.body.scrollTop }; } function c(t, e) { return 100 / (e - t); } function p(t, e, r) { return 100 * e / (t[r + 1] - t[r]); } function f(t, e) { for (var r = 1; t >= e[r];)r += 1; return r; } function r(t, e, r) { if (r >= t.slice(-1)[0]) return 100; let n; let i; const o = f(r, t); const s = t[o - 1]; const a = t[o]; const l = e[o - 1]; const u = e[o]; return l + (i = r, p(n = [s, a], n[0] < 0 ? i + Math.abs(n[0]) : i - n[0], 0) / c(l, u)); } function n(t, e, r, n) { if (n === 100) return n; let i; let o; const s = f(n, t); const a = t[s - 1]; const l = t[s]; return r ? (l - a) / 2 < n - a ? l : a : e[s - 1] ? t[s - 1] + (i = n - t[s - 1], o = e[s - 1], Math.round(i / o) * o) : n; } function s(t, e, r) { let n; if (typeof e === 'number' && (e = [e]), !Array.isArray(e)) throw new Error(`noUiSlider (${lt}): 'range' contains invalid value.`); if (!o(n = t === 'min' ? 0 : t === 'max' ? 100 : parseFloat(t)) || !o(e[0])) throw new Error(`noUiSlider (${lt}): 'range' value isn't numeric.`); r.xPct.push(n), r.xVal.push(e[0]), n ? r.xSteps.push(!isNaN(e[1]) && e[1]) : isNaN(e[1]) || (r.xSteps[0] = e[1]), r.xHighestCompleteStep.push(0); } function l(t, e, r) { if (e) if (r.xVal[t] !== r.xVal[t + 1]) { r.xSteps[t] = p([r.xVal[t], r.xVal[t + 1]], e, 0) / c(r.xPct[t], r.xPct[t + 1]); const n = (r.xVal[t + 1] - r.xVal[t]) / r.xNumSteps[t]; const i = Math.ceil(Number(n.toFixed(3)) - 1); const o = r.xVal[t] + r.xNumSteps[t] * i; r.xHighestCompleteStep[t] = o; } else r.xSteps[t] = r.xHighestCompleteStep[t] = r.xVal[t]; } function i(t, e, r) { let n; this.xPct = [], this.xVal = [], this.xSteps = [r || !1], this.xNumSteps = [!1], this.xHighestCompleteStep = [], this.snap = e; const i = []; for (n in t)t.hasOwnProperty(n) && i.push([t[n], n]); for (i.length && typeof i[0][0] === 'object' ? i.sort((t, e) => t[0][0] - e[0][0]) : i.sort((t, e) => t[0] - e[0]), n = 0; n < i.length; n++)s(i[n][1], i[n][0], this); for (this.xNumSteps = this.xSteps.slice(0), n = 0; n < this.xNumSteps.length; n++)l(n, this.xNumSteps[n], this); }i.prototype.getDistance = function (t) { let e; const r = []; for (e = 0; e < this.xNumSteps.length - 1; e++) { const n = this.xNumSteps[e]; if (n && t / n % 1 != 0) throw new Error(`noUiSlider (${lt}): 'limit', 'margin' and 'padding' of ${this.xPct[e]}% range must be divisible by step.`); r[e] = p(this.xVal, t, e); } return r; }, i.prototype.getAbsoluteDistance = function (t, e, r) { let n; let i = 0; if (t < this.xPct[this.xPct.length - 1]) for (;t > this.xPct[i + 1];)i++; else t === this.xPct[this.xPct.length - 1] && (i = this.xPct.length - 2); r || t !== this.xPct[i + 1] || i++; let o = 1; let s = e[i]; let a = 0; let l = 0; let u = 0; let c = 0; for (n = r ? (t - this.xPct[i]) / (this.xPct[i + 1] - this.xPct[i]) : (this.xPct[i + 1] - t) / (this.xPct[i + 1] - this.xPct[i]); s > 0;)a = this.xPct[i + 1 + c] - this.xPct[i + c], e[i + c] * o + 100 - 100 * n > 100 ? (l = a * n, o = (s - 100 * n) / e[i + c], n = 1) : (l = e[i + c] * a / 100 * o, o = 0), r ? (u -= l, this.xPct.length + c >= 1 && c--) : (u += l, this.xPct.length - c >= 1 && c++), s = e[i + c] * o; return t + u; }, i.prototype.toStepping = function (t) { return t = r(this.xVal, this.xPct, t); }, i.prototype.fromStepping = function (t) { return (function (t, e, r) { if (r >= 100) return t.slice(-1)[0]; let n; const i = f(r, e); const o = t[i - 1]; const s = t[i]; const a = e[i - 1]; const l = e[i]; return n = [o, s], (r - a) * c(a, l) * (n[1] - n[0]) / 100 + n[0]; }(this.xVal, this.xPct, t)); }, i.prototype.getStep = function (t) { return t = n(this.xPct, this.xSteps, this.snap, t); }, i.prototype.getDefaultStep = function (t, e, r) { let n = f(t, this.xPct); return (t === 100 || e && t === this.xPct[n - 1]) && (n = Math.max(n - 1, 1)), (this.xVal[n] - this.xVal[n - 1]) / r; }, i.prototype.getNearbySteps = function (t) { const e = f(t, this.xPct); return { stepBefore: { startValue: this.xVal[e - 2], step: this.xNumSteps[e - 2], highestStep: this.xHighestCompleteStep[e - 2] }, thisStep: { startValue: this.xVal[e - 1], step: this.xNumSteps[e - 1], highestStep: this.xHighestCompleteStep[e - 1] }, stepAfter: { startValue: this.xVal[e], step: this.xNumSteps[e], highestStep: this.xHighestCompleteStep[e] } }; }, i.prototype.countStepDecimals = function () { const t = this.xNumSteps.map(e); return Math.max.apply(null, t); }, i.prototype.convert = function (t) { return this.getStep(this.toStepping(t)); }; const u = { to(t) { return void 0 !== t && t.toFixed(2); }, from: Number }; const d = {
    target: 'target', base: 'base', origin: 'origin', handle: 'handle', handleLower: 'handle-lower', handleUpper: 'handle-upper', touchArea: 'touch-area', horizontal: 'horizontal', vertical: 'vertical', background: 'background', connect: 'connect', connects: 'connects', ltr: 'ltr', rtl: 'rtl', textDirectionLtr: 'txt-dir-ltr', textDirectionRtl: 'txt-dir-rtl', draggable: 'draggable', drag: 'state-drag', tap: 'state-tap', active: 'active', tooltip: 'tooltip', pips: 'pips', pipsHorizontal: 'pips-horizontal', pipsVertical: 'pips-vertical', marker: 'marker', markerHorizontal: 'marker-horizontal', markerVertical: 'marker-vertical', markerNormal: 'marker-normal', markerLarge: 'marker-large', markerSub: 'marker-sub', value: 'value', valueHorizontal: 'value-horizontal', valueVertical: 'value-vertical', valueNormal: 'value-normal', valueLarge: 'value-large', valueSub: 'value-sub',
  }; function h(t) { if (typeof (e = t) === 'object' && typeof e.to === 'function' && typeof e.from === 'function') return !0; let e; throw new Error(`noUiSlider (${lt}): 'format' requires 'to' and 'from' methods.`); } function m(t, e) { if (!o(e)) throw new Error(`noUiSlider (${lt}): 'step' is not numeric.`); t.singleStep = e; } function g(t, e) { if (!o(e)) throw new Error(`noUiSlider (${lt}): 'keyboardPageMultiplier' is not numeric.`); t.keyboardPageMultiplier = e; } function v(t, e) { if (!o(e)) throw new Error(`noUiSlider (${lt}): 'keyboardDefaultStep' is not numeric.`); t.keyboardDefaultStep = e; } function b(t, e) { if (typeof e !== 'object' || Array.isArray(e)) throw new Error(`noUiSlider (${lt}): 'range' is not an object.`); if (void 0 === e.min || void 0 === e.max) throw new Error(`noUiSlider (${lt}): Missing 'min' or 'max' in 'range'.`); if (e.min === e.max) throw new Error(`noUiSlider (${lt}): 'range' 'min' and 'max' cannot be equal.`); t.spectrum = new i(e, t.snap, t.singleStep); } function x(t, e) { if (e = dt(e), !Array.isArray(e) || !e.length) throw new Error(`noUiSlider (${lt}): 'start' option is incorrect.`); t.handles = e.length, t.start = e; } function S(t, e) { if (typeof (t.snap = e) !== 'boolean') throw new Error(`noUiSlider (${lt}): 'snap' option must be a boolean.`); } function w(t, e) { if (typeof (t.animate = e) !== 'boolean') throw new Error(`noUiSlider (${lt}): 'animate' option must be a boolean.`); } function y(t, e) { if (typeof (t.animationDuration = e) !== 'number') throw new Error(`noUiSlider (${lt}): 'animationDuration' option must be a number.`); } function E(t, e) { let r; let n = [!1]; if (e === 'lower' ? e = [!0, !1] : e === 'upper' && (e = [!1, !0]), !0 === e || !1 === e) { for (r = 1; r < t.handles; r++)n.push(e); n.push(!1); } else { if (!Array.isArray(e) || !e.length || e.length !== t.handles + 1) throw new Error(`noUiSlider (${lt}): 'connect' option doesn't match handle count.`); n = e; }t.connect = n; } function C(t, e) { switch (e) { case 'horizontal': t.ort = 0; break; case 'vertical': t.ort = 1; break; default: throw new Error(`noUiSlider (${lt}): 'orientation' option is invalid.`); } } function P(t, e) { if (!o(e)) throw new Error(`noUiSlider (${lt}): 'margin' option must be numeric.`); e !== 0 && (t.margin = t.spectrum.getDistance(e)); } function N(t, e) { if (!o(e)) throw new Error(`noUiSlider (${lt}): 'limit' option must be numeric.`); if (t.limit = t.spectrum.getDistance(e), !t.limit || t.handles < 2) throw new Error(`noUiSlider (${lt}): 'limit' option is only supported on linear sliders with 2 or more handles.`); } function k(t, e) { let r; if (!o(e) && !Array.isArray(e)) throw new Error(`noUiSlider (${lt}): 'padding' option must be numeric or array of exactly 2 numbers.`); if (Array.isArray(e) && e.length !== 2 && !o(e[0]) && !o(e[1])) throw new Error(`noUiSlider (${lt}): 'padding' option must be numeric or array of exactly 2 numbers.`); if (e !== 0) { for (Array.isArray(e) || (e = [e, e]), t.padding = [t.spectrum.getDistance(e[0]), t.spectrum.getDistance(e[1])], r = 0; r < t.spectrum.xNumSteps.length - 1; r++) if (t.padding[0][r] < 0 || t.padding[1][r] < 0) throw new Error(`noUiSlider (${lt}): 'padding' option must be a positive number(s).`); const n = e[0] + e[1]; const i = t.spectrum.xVal[0]; if (n / (t.spectrum.xVal[t.spectrum.xVal.length - 1] - i) > 1) throw new Error(`noUiSlider (${lt}): 'padding' option must not exceed 100% of the range.`); } } function U(t, e) { switch (e) { case 'ltr': t.dir = 0; break; case 'rtl': t.dir = 1; break; default: throw new Error(`noUiSlider (${lt}): 'direction' option was not recognized.`); } } function A(t, e) {
    if (typeof e !== 'string') throw new Error(`noUiSlider (${lt}): 'behaviour' must be a string containing options.`); const r = e.indexOf('tap') >= 0; const n = e.indexOf('drag') >= 0; const i = e.indexOf('fixed') >= 0; const o = e.indexOf('snap') >= 0; const s = e.indexOf('hover') >= 0; const a = e.indexOf('unconstrained') >= 0; if (i) { if (t.handles !== 2) throw new Error(`noUiSlider (${lt}): 'fixed' behaviour must be used with 2 handles`); P(t, t.start[1] - t.start[0]); } if (a && (t.margin || t.limit)) throw new Error(`noUiSlider (${lt}): 'unconstrained' behaviour cannot be used with margin or limit`); t.events = {
      tap: r || o, drag: n, fixed: i, snap: o, hover: s, unconstrained: a,
    };
  } function V(t, e) { if (!1 !== e) if (!0 === e) { t.tooltips = []; for (let r = 0; r < t.handles; r++)t.tooltips.push(!0); } else { if (t.tooltips = dt(e), t.tooltips.length !== t.handles) throw new Error(`noUiSlider (${lt}): must pass a formatter for all handles.`); t.tooltips.forEach((t) => { if (typeof t !== 'boolean' && (typeof t !== 'object' || typeof t.to !== 'function')) throw new Error(`noUiSlider (${lt}): 'tooltips' must be passed a formatter or 'false'.`); }); } } function D(t, e) { h(t.ariaFormat = e); } function M(t, e) { h(t.format = e); } function O(t, e) { if (typeof (t.keyboardSupport = e) !== 'boolean') throw new Error(`noUiSlider (${lt}): 'keyboardSupport' option must be a boolean.`); } function L(t, e) { t.documentElement = e; } function z(t, e) { if (typeof e !== 'string' && !1 !== e) throw new Error(`noUiSlider (${lt}): 'cssPrefix' must be a string or \`false\`.`); t.cssPrefix = e; } function H(t, e) { if (typeof e !== 'object') throw new Error(`noUiSlider (${lt}): 'cssClasses' must be an object.`); if (typeof t.cssPrefix === 'string') for (const r in t.cssClasses = {}, e)e.hasOwnProperty(r) && (t.cssClasses[r] = t.cssPrefix + e[r]); else t.cssClasses = e; } function vt(e) {
    const r = {
      margin: 0, limit: 0, padding: 0, animate: !0, animationDuration: 300, ariaFormat: u, format: u,
    }; const n = {
      step: { r: !1, t: m }, keyboardPageMultiplier: { r: !1, t: g }, keyboardDefaultStep: { r: !1, t: v }, start: { r: !0, t: x }, connect: { r: !0, t: E }, direction: { r: !0, t: U }, snap: { r: !1, t: S }, animate: { r: !1, t: w }, animationDuration: { r: !1, t: y }, range: { r: !0, t: b }, orientation: { r: !1, t: C }, margin: { r: !1, t: P }, limit: { r: !1, t: N }, padding: { r: !1, t: k }, behaviour: { r: !0, t: A }, ariaFormat: { r: !1, t: D }, format: { r: !1, t: M }, tooltips: { r: !1, t: V }, keyboardSupport: { r: !0, t: O }, documentElement: { r: !1, t: L }, cssPrefix: { r: !0, t: z }, cssClasses: { r: !0, t: H },
    }; const i = {
      connect: !1, direction: 'ltr', behaviour: 'tap', orientation: 'horizontal', keyboardSupport: !0, cssPrefix: 'noUi-', cssClasses: d, keyboardPageMultiplier: 5, keyboardDefaultStep: 10,
    }; e.format && !e.ariaFormat && (e.ariaFormat = e.format), Object.keys(n).forEach((t) => { if (!a(e[t]) && void 0 === i[t]) { if (n[t].r) throw new Error(`noUiSlider (${lt}): '${t}' is required.`); return !0; }n[t].t(r, a(e[t]) ? e[t] : i[t]); }), r.pips = e.pips; const t = document.createElement('div'); const o = void 0 !== t.style.msTransform; const s = void 0 !== t.style.transform; r.transformRule = s ? 'transform' : o ? 'msTransform' : 'webkitTransform'; return r.style = [['left', 'top'], ['right', 'bottom']][r.dir][r.ort], r;
  } function j(t, b, o) {
    let l; let u; let s; let c; let i; let a; let e; let p; const f = window.navigator.pointerEnabled ? { start: 'pointerdown', move: 'pointermove', end: 'pointerup' } : window.navigator.msPointerEnabled ? { start: 'MSPointerDown', move: 'MSPointerMove', end: 'MSPointerUp' } : { start: 'mousedown touchstart', move: 'mousemove touchmove', end: 'mouseup touchend' }; const d = window.CSS && CSS.supports && CSS.supports('touch-action', 'none') && (function () { let t = !1; try { const e = Object.defineProperty({}, 'passive', { get() { t = !0; } }); window.addEventListener('test', null, e); } catch (t) {} return t; }()); const h = t; let y = b.spectrum; const x = []; let S = []; const m = []; let g = 0; const v = {}; const w = t.ownerDocument; const E = b.documentElement || w.documentElement; const C = w.body; const P = -1; const N = 0; const k = 1; const U = 2; const A = w.dir === 'rtl' || b.ort === 1 ? 0 : 100; function V(t, e) { const r = w.createElement('div'); return e && ht(r, e), t.appendChild(r), r; } function D(t, e) { const r = V(t, b.cssClasses.origin); const n = V(r, b.cssClasses.handle); return V(n, b.cssClasses.touchArea), n.setAttribute('data-handle', e), b.keyboardSupport && (n.setAttribute('tabindex', '0'), n.addEventListener('keydown', (t) => (function (t, e) { if (O() || L(e)) return !1; const r = ['Left', 'Right']; const n = ['Down', 'Up']; const i = ['PageDown', 'PageUp']; const o = ['Home', 'End']; b.dir && !b.ort ? r.reverse() : b.ort && !b.dir && (n.reverse(), i.reverse()); let s; const a = t.key.replace('Arrow', ''); const l = a === i[0]; const u = a === i[1]; const c = a === n[0] || a === r[0] || l; const p = a === n[1] || a === r[1] || u; const f = a === o[0]; const d = a === o[1]; if (!(c || p || f || d)) return !0; if (t.preventDefault(), p || c) { const h = b.keyboardPageMultiplier; const m = c ? 0 : 1; const g = at(e); let v = g[m]; if (v === null) return !1; !1 === v && (v = y.getDefaultStep(S[e], c, b.keyboardDefaultStep)), (u || l) && (v *= h), v = Math.max(v, 1e-7), v *= c ? -1 : 1, s = x[e] + v; } else s = d ? b.spectrum.xVal[b.spectrum.xVal.length - 1] : b.spectrum.xVal[0]; return rt(e, y.toStepping(s), !0, !0), J('slide', e), J('update', e), J('change', e), J('set', e), !1; }(t, e)))), n.setAttribute('role', 'slider'), n.setAttribute('aria-orientation', b.ort ? 'vertical' : 'horizontal'), e === 0 ? ht(n, b.cssClasses.handleLower) : e === b.handles - 1 && ht(n, b.cssClasses.handleUpper), r; } function M(t, e) { return !!e && V(t, b.cssClasses.connect); } function r(t, e) { return !!b.tooltips[e] && V(t.firstChild, b.cssClasses.tooltip); } function O() { return h.hasAttribute('disabled'); } function L(t) { return u[t].hasAttribute('disabled'); } function z() { i && (G('update.tooltips'), i.forEach((t) => { t && ut(t); }), i = null); } function H() { z(), i = u.map(r), $('update.tooltips', (t, e, r) => { if (i[e]) { let n = t[e]; !0 !== b.tooltips[e] && (n = b.tooltips[e].to(r[e])), i[e].innerHTML = n; } }); } function j(e, i, o) { const s = w.createElement('div'); const a = []; a[N] = b.cssClasses.valueNormal, a[k] = b.cssClasses.valueLarge, a[U] = b.cssClasses.valueSub; const l = []; l[N] = b.cssClasses.markerNormal, l[k] = b.cssClasses.markerLarge, l[U] = b.cssClasses.markerSub; const u = [b.cssClasses.valueHorizontal, b.cssClasses.valueVertical]; const c = [b.cssClasses.markerHorizontal, b.cssClasses.markerVertical]; function p(t, e) { const r = e === b.cssClasses.value; const n = r ? a : l; return `${e} ${(r ? u : c)[b.ort]} ${n[t]}`; } return ht(s, b.cssClasses.pips), ht(s, b.ort === 0 ? b.cssClasses.pipsHorizontal : b.cssClasses.pipsVertical), Object.keys(e).forEach((t) => { !(function (t, e, r) { if ((r = i ? i(e, r) : r) !== P) { let n = V(s, !1); n.className = p(r, b.cssClasses.marker), n.style[b.style] = `${t}%`, N < r && ((n = V(s, !1)).className = p(r, b.cssClasses.value), n.setAttribute('data-value', e), n.style[b.style] = `${t}%`, n.innerHTML = o.to(e)); } }(t, e[t][0], e[t][1])); }), s; } function F() { c && (ut(c), c = null); } function R(t) { F(); let m; let g; let v; let b; let e; let r; let x; let S; let w; const n = t.mode; const i = t.density || 1; const o = t.filter || !1; const s = (function (t, e, r) { if (t === 'range' || t === 'steps') return y.xVal; if (t === 'count') { if (e < 2) throw new Error(`noUiSlider (${lt}): 'values' (>= 2) required for mode 'count'.`); let n = e - 1; const i = 100 / n; for (e = []; n--;)e[n] = n * i; e.push(100), t = 'positions'; } return t === 'positions' ? e.map((t) => y.fromStepping(r ? y.getStep(t) : t)) : t === 'values' ? r ? e.map((t) => y.fromStepping(y.getStep(y.toStepping(t)))) : e : void 0; }(n, t.values || !1, t.stepped || !1)); const a = (m = i, g = n, v = s, b = {}, e = y.xVal[0], r = y.xVal[y.xVal.length - 1], S = x = !1, w = 0, (v = v.slice().sort((t, e) => t - e).filter(function (t) { return !this[t] && (this[t] = !0); }, {}))[0] !== e && (v.unshift(e), x = !0), v[v.length - 1] !== r && (v.push(r), S = !0), v.forEach((t, e) => { let r; let n; let i; let o; let s; let a; let l; let u; let c; let p; const f = t; let d = v[e + 1]; const h = g === 'steps'; if (h && (r = y.xNumSteps[e]), r || (r = d - f), !1 !== f) for (void 0 === d && (d = f), r = Math.max(r, 1e-7), n = f; n <= d; n = (n + r).toFixed(7) / 1) { for (u = (s = (o = y.toStepping(n)) - w) / m, p = s / (c = Math.round(u)), i = 1; i <= c; i += 1)b[(a = w + i * p).toFixed(5)] = [y.fromStepping(a), 0]; l = v.indexOf(n) > -1 ? k : h ? U : N, !e && x && n !== d && (l = 0), n === d && S || (b[o.toFixed(5)] = [n, l]), w = o; } }), b); const l = t.format || { to: Math.round }; return c = h.appendChild(j(a, o, l)); } function T() { const t = l.getBoundingClientRect(); const e = `offset${['Width', 'Height'][b.ort]}`; return b.ort === 0 ? t.width || l[e] : t.height || l[e]; } function B(n, i, o, s) { const e = function (t) { return !!(t = (function (t, e, r) { let n; let i; const o = t.type.indexOf('touch') === 0; const s = t.type.indexOf('mouse') === 0; let a = t.type.indexOf('pointer') === 0; t.type.indexOf('MSPointer') === 0 && (a = !0); if (t.type === 'mousedown' && !t.buttons && !t.touches) return !1; if (o) { const l = function (t) { return t.target === r || r.contains(t.target) || t.target.shadowRoot && t.target.shadowRoot.contains(r); }; if (t.type === 'touchstart') { const u = Array.prototype.filter.call(t.touches, l); if (u.length > 1) return !1; n = u[0].pageX, i = u[0].pageY; } else { const c = Array.prototype.find.call(t.changedTouches, l); if (!c) return !1; n = c.pageX, i = c.pageY; } }e = e || gt(w), (s || a) && (n = t.clientX + e.x, i = t.clientY + e.y); return t.pageOffset = e, t.points = [n, i], t.cursor = s || a, t; }(t, s.pageOffset, s.target || i))) && (!(O() && !s.doNotReject) && (e = h, r = b.cssClasses.tap, !((e.classList ? e.classList.contains(r) : new RegExp(`\\b${r}\\b`).test(e.className)) && !s.doNotReject) && (!(n === f.start && void 0 !== t.buttons && t.buttons > 1) && ((!s.hover || !t.buttons) && (d || t.preventDefault(), t.calcPoint = t.points[b.ort], void o(t, s)))))); let e; let r; }; const r = []; return n.split(' ').forEach((t) => { i.addEventListener(t, e, !!d && { passive: !0 }), r.push([t, e]); }), r; } function q(t) { let e; let r; let n; let i; let o; let s; let a = 100 * (t - (e = l, r = b.ort, n = e.getBoundingClientRect(), i = e.ownerDocument, o = i.documentElement, s = gt(i), /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) && (s.x = 0), r ? n.top + s.y - o.clientTop : n.left + s.x - o.clientLeft)) / T(); return a = ft(a), b.dir ? 100 - a : a; } function X(t, e) { t.type === 'mouseout' && t.target.nodeName === 'HTML' && t.relatedTarget === null && _(t, e); } function Y(t, e) { if (navigator.appVersion.indexOf('MSIE 9') === -1 && t.buttons === 0 && e.buttonsProperty !== 0) return _(t, e); const r = (b.dir ? -1 : 1) * (t.calcPoint - e.startCalcPoint); Z(r > 0, 100 * r / e.baseSize, e.locations, e.handleNumbers); } function _(t, e) { e.handle && (mt(e.handle, b.cssClasses.active), g -= 1), e.listeners.forEach((t) => { E.removeEventListener(t[0], t[1]); }), g === 0 && (mt(h, b.cssClasses.drag), et(), t.cursor && (C.style.cursor = '', C.removeEventListener('selectstart', ct))), e.handleNumbers.forEach((t) => { J('change', t), J('set', t), J('end', t); }); } function I(t, e) {
      if (e.handleNumbers.some(L)) return !1; let r; e.handleNumbers.length === 1 && (r = u[e.handleNumbers[0]].children[0], g += 1, ht(r, b.cssClasses.active)); t.stopPropagation(); const n = []; const i = B(f.move, E, Y, {
        target: t.target, handle: r, listeners: n, startCalcPoint: t.calcPoint, baseSize: T(), pageOffset: t.pageOffset, handleNumbers: e.handleNumbers, buttonsProperty: t.buttons, locations: S.slice(),
      }); const o = B(f.end, E, _, {
        target: t.target, handle: r, listeners: n, doNotReject: !0, handleNumbers: e.handleNumbers,
      }); const s = B('mouseout', E, X, {
        target: t.target, handle: r, listeners: n, doNotReject: !0, handleNumbers: e.handleNumbers,
      }); n.push.apply(n, i.concat(o, s)), t.cursor && (C.style.cursor = getComputedStyle(t.target).cursor, u.length > 1 && ht(h, b.cssClasses.drag), C.addEventListener('selectstart', ct, !1)), e.handleNumbers.forEach((t) => { J('start', t); });
    } function n(t) { t.stopPropagation(); let i; let o; let s; const e = q(t.calcPoint); const r = (i = e, s = !(o = 100), u.forEach((t, e) => { if (!L(e)) { const r = S[e]; const n = Math.abs(r - i); (n < o || n <= o && r < i || n === 100 && o === 100) && (s = e, o = n); } }), s); if (!1 === r) return !1; b.events.snap || pt(h, b.cssClasses.tap, b.animationDuration), rt(r, e, !0, !0), et(), J('slide', r, !0), J('update', r, !0), J('change', r, !0), J('set', r, !0), b.events.snap && I(t, { handleNumbers: [r] }); } function W(t) { const e = q(t.calcPoint); const r = y.getStep(e); const n = y.fromStepping(r); Object.keys(v).forEach((t) => { t.split('.')[0] === 'hover' && v[t].forEach((t) => { t.call(a, n); }); }); } function $(t, e) { v[t] = v[t] || [], v[t].push(e), t.split('.')[0] === 'update' && u.forEach((t, e) => { J('update', e); }); } function G(t) { const n = t && t.split('.')[0]; const i = n && t.substring(n.length); Object.keys(v).forEach((t) => { const e = t.split('.')[0]; const r = t.substring(e.length); n && n !== e || i && i !== r || delete v[t]; }); } function J(r, n, i) { Object.keys(v).forEach((t) => { const e = t.split('.')[0]; r === e && v[t].forEach((t) => { t.call(a, x.map(b.format.to), n, x.slice(), i || !1, S.slice(), a); }); }); } function K(t, e, r, n, i, o) { let s; return u.length > 1 && !b.events.unconstrained && (n && e > 0 && (s = y.getAbsoluteDistance(t[e - 1], b.margin, 0), r = Math.max(r, s)), i && e < u.length - 1 && (s = y.getAbsoluteDistance(t[e + 1], b.margin, 1), r = Math.min(r, s))), u.length > 1 && b.limit && (n && e > 0 && (s = y.getAbsoluteDistance(t[e - 1], b.limit, 0), r = Math.min(r, s)), i && e < u.length - 1 && (s = y.getAbsoluteDistance(t[e + 1], b.limit, 1), r = Math.max(r, s))), b.padding && (e === 0 && (s = y.getAbsoluteDistance(0, b.padding[0], 0), r = Math.max(r, s)), e === u.length - 1 && (s = y.getAbsoluteDistance(100, b.padding[1], 1), r = Math.min(r, s))), !((r = ft(r = y.getStep(r))) === t[e] && !o) && r; } function Q(t, e) { const r = b.ort; return `${r ? e : t}, ${r ? t : e}`; } function Z(t, n, r, e) { const i = r.slice(); let o = [!t, t]; let s = [t, !t]; e = e.slice(), t && e.reverse(), e.length > 1 ? e.forEach((t, e) => { const r = K(i, t, i[t] + n, o[e], s[e], !1); !1 === r ? n = 0 : (n = r - i[t], i[t] = r); }) : o = s = [!0]; let a = !1; e.forEach((t, e) => { a = rt(t, r[t] + n, o[e], s[e]) || a; }), a && e.forEach((t) => { J('update', t), J('slide', t); }); } function tt(t, e) { return b.dir ? 100 - t - e : t; } function et() { m.forEach((t) => { const e = S[t] > 50 ? -1 : 1; const r = 3 + (u.length + e * t); u[t].style.zIndex = r; }); } function rt(t, e, r, n, i) { return i || (e = K(S, t, e, r, n, !1)), !1 !== e && ((function (t, e) { S[t] = e, x[t] = y.fromStepping(e); const r = `translate(${Q(`${10 * (tt(e, 0) - A)}%`, '0')})`; u[t].style[b.transformRule] = r, nt(t), nt(t + 1); }(t, e)), !0); } function nt(t) { if (s[t]) { let e = 0; let r = 100; t !== 0 && (e = S[t - 1]), t !== s.length - 1 && (r = S[t]); const n = r - e; const i = `translate(${Q(`${tt(e, n)}%`, '0')})`; const o = `scale(${Q(n / 100, '1')})`; s[t].style[b.transformRule] = `${i} ${o}`; } } function it(t, e) { return t === null || !1 === t || void 0 === t ? S[e] : (typeof t === 'number' && (t = String(t)), t = b.format.from(t), !1 === (t = y.toStepping(t)) || isNaN(t) ? S[e] : t); } function ot(t, e, r) { const n = dt(t); const i = void 0 === S[0]; e = void 0 === e || !!e, b.animate && !i && pt(h, b.cssClasses.tap, b.animationDuration), m.forEach((t) => { rt(t, it(n[t], t), !0, !1, r); }); for (let o = m.length === 1 ? 0 : 1; o < m.length; ++o)m.forEach((t) => { rt(t, S[t], !0, !0, r); }); et(), m.forEach((t) => { J('update', t), n[t] !== null && e && J('set', t); }); } function st() { const t = x.map(b.format.to); return t.length === 1 ? t[0] : t; } function at(t) { const e = S[t]; const r = y.getNearbySteps(e); const n = x[t]; let i = r.thisStep.step; let o = null; if (b.snap) return [n - r.stepBefore.startValue || null, r.stepAfter.startValue - n || null]; !1 !== i && n + i > r.stepAfter.startValue && (i = r.stepAfter.startValue - n), o = n > r.thisStep.startValue ? r.thisStep.step : !1 !== r.stepBefore.step && n - r.stepBefore.highestStep, e === 100 ? i = null : e === 0 && (o = null); const s = y.countStepDecimals(); return i !== null && !1 !== i && (i = Number(i.toFixed(s))), o !== null && !1 !== o && (o = Number(o.toFixed(s))), [o, i]; } return ht(e = h, b.cssClasses.target), b.dir === 0 ? ht(e, b.cssClasses.ltr) : ht(e, b.cssClasses.rtl), b.ort === 0 ? ht(e, b.cssClasses.horizontal) : ht(e, b.cssClasses.vertical), ht(e, getComputedStyle(e).direction === 'rtl' ? b.cssClasses.textDirectionRtl : b.cssClasses.textDirectionLtr), l = V(e, b.cssClasses.base), (function (t, e) { const r = V(e, b.cssClasses.connects); u = [], (s = []).push(M(r, t[0])); for (let n = 0; n < b.handles; n++)u.push(D(e, n)), m[n] = n, s.push(M(r, t[n + 1])); }(b.connect, l)), (p = b.events).fixed || u.forEach((t, e) => { B(f.start, t.children[0], I, { handleNumbers: [e] }); }), p.tap && B(f.start, l, n, {}), p.hover && B(f.move, l, W, { hover: !0 }), p.drag && s.forEach((t, e) => { if (!1 !== t && e !== 0 && e !== s.length - 1) { const r = u[e - 1]; const n = u[e]; const i = [t]; ht(t, b.cssClasses.draggable), p.fixed && (i.push(r.children[0]), i.push(n.children[0])), i.forEach((t) => { B(f.start, t, I, { handles: [r, n], handleNumbers: [e - 1, e] }); }); } }), ot(b.start), b.pips && R(b.pips), b.tooltips && H(), $('update', (t, e, s, r, a) => { m.forEach((t) => { const e = u[t]; let r = K(S, t, 0, !0, !0, !0); let n = K(S, t, 100, !0, !0, !0); let i = a[t]; const o = b.ariaFormat.to(s[t]); r = y.fromStepping(r).toFixed(1), n = y.fromStepping(n).toFixed(1), i = y.fromStepping(i).toFixed(1), e.children[0].setAttribute('aria-valuemin', r), e.children[0].setAttribute('aria-valuemax', n), e.children[0].setAttribute('aria-valuenow', i), e.children[0].setAttribute('aria-valuetext', o); }); }), a = {
      destroy() { for (const t in b.cssClasses)b.cssClasses.hasOwnProperty(t) && mt(h, b.cssClasses[t]); for (;h.firstChild;)h.removeChild(h.firstChild); delete h.noUiSlider; }, steps() { return m.map(at); }, on: $, off: G, get: st, set: ot, setHandle(t, e, r, n) { if (!((t = Number(t)) >= 0 && t < m.length)) throw new Error(`noUiSlider (${lt}): invalid handle number, got: ${t}`); rt(t, it(e, t), !0, !0, n), J('update', t), r && J('set', t); }, reset(t) { ot(b.start, t); }, __moveHandles(t, e, r) { Z(t, e, S, r); }, options: o, updateOptions(e, t) { const r = st(); const n = ['margin', 'limit', 'padding', 'range', 'animate', 'snap', 'step', 'format', 'pips', 'tooltips']; n.forEach((t) => { void 0 !== e[t] && (o[t] = e[t]); }); const i = vt(o); n.forEach((t) => { void 0 !== e[t] && (b[t] = i[t]); }), y = i.spectrum, b.margin = i.margin, b.limit = i.limit, b.padding = i.padding, b.pips ? R(b.pips) : F(), b.tooltips ? H() : z(), S = [], ot(e.start || r, t); }, target: h, removePips: F, removeTooltips: z, getTooltips() { return i; }, getOrigins() { return u; }, pips: R,
    };
  } return {
    __spectrum: i, version: lt, cssClasses: d, create(t, e) { if (!t || !t.nodeName) throw new Error(`noUiSlider (${lt}): create requires a single element, got: ${t}`); if (t.noUiSlider) throw new Error(`noUiSlider (${lt}): Slider was already initialized.`); const r = j(t, vt(e), e); return t.noUiSlider = r; },
  };
}));
